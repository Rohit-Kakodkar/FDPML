PROGRAM FDPML
!	FDPML method to solve phonon scattering problems

!	Pre-requisites:		Primary domain should be generated using 
!						gendomain.f90 provided in this repository
!						Force constant file should generated using Quantum Espresso in *.fc format
!
!	
! 	FDPML calculates scattering properties for a particular phonon mode 
!	(wavevector and polarization resolved) inside nanostructured materials.
!	For in-depth discription of the method refer 
!	kakodkar et. al. Journal of Applied Physics 118, 094301 (2015)
!	
!	Input cards :
!	&filenames
!		flfrc1 = force constant file of the matrix material (should be generated via
!				 Quantum espresso). NOT IN XML FORMAT
!		flfrc2 = force constant file of impurity material (should be generated via
!				 Quantum espresso). NOT IN XML FORMAT
!		mass_input = logical, if true masses are calculated with atomic resolution
!							  else masses are calculated based on supercell
!		mass_file = mass domain file generated by gendomain.f90
!		domain_file = domain specification generated by gendomain.f90
!	&system
!		simulation_type = 'interface' or 'nanoparticle'
!		PD = size of the primary domain, should be same as the one generated
!			 gendomain.f90
!		LPML = length of PML. Ignored if PML calculation is auto
!		periodic = logical, if true applied periodic boundaries in x and y direction
!		crystal_coordinates = logical, if true work in crystal coordinates
!		asr = acoustic sum rule. Refer QE documentation
!		wavetype = 'half' or 'full' to specify type of incidnet wave
!		q = wavevector, ignored if mp = .true.
!		mode = polarization
!		sigmamax = maximum value of damping coefficient, Ignored if PML calculation is auto
!		mp = generate qpoint list base Monkhorst Pack(MP) grid
!		qpoint = n, then choose nth q from list of q generated by MP grid
!		nk1, nk2, nk3 = k-spacings in x,y and z directions for MP grid
!	&postprocessing
!		calc_TC = logical, calculate transmission coefficient (for interface problems)
!		calc_gam = logical, calculate scattering cross-section (for nanoparticle problems)
!	&plotting
!		plot_K  = logical, plot variation of K vector on TD(3)/2 plane
!		plot_uinc = logical, plot incident wave
!		plot_uscat = logical, plot scattered wave
!		plot_sig = logical, plot variation of damping coefficient
!		plottingmode = 1, 2, or 3, plot x, y, or z components of above properties

	USE mp_module
	USE io_module
	USE kinds
	USE lapack95
	USE blas95
	USE f95_precision
	USE essentials
	USE sum_rule
	USE rigid
	USE ws
	USE dispersion
	USE gnufor2
	USE COO_routines
	USE bicg
	USE monkhorstpack
	USE init
	USE preprocessing_module
	USE matgen_module
	use, intrinsic :: iso_fortran_env, only : stdin=>input_unit, &
											  stdout=>output_unit, &
											  stderr=>error_unit
	USE constants, ONLY : tpi, amu_ry, RY_TO_CMM1, RY_TO_THZ, BOHR_RADIUS_SI, GB_byte
											  
	IMPLICIT NONE
	INCLUDE 'mpif.h' ! MPI header file
	INCLUDE 'mkl.fi' ! MKL header file
	
!	*****************************************************************************************
!	query variables
	INTEGER, PARAMETER 				:: 	nrwsx = 200
	INTEGER 						:: 	rcl
!	*****************************************************************************************
!	Filenames and booleans
	CHARACTER(len = 256) 			:: 	mass_file, domain_file, simulation_type, &
										qlist_file, slist_file, Llist_file, timing_file
	INTEGER							::	spoint, Lpoint
	REAL(KIND = RP), ALLOCATABLE	::	slist(:)
	INTEGER, ALLOCATABLE 			:: 	Llist(:)
	LOGICAL 						::	mass_input, crystal_coordinates, &
										exit_status, file_input
!	*****************************************************************************************
!	Force constant variables
	CHARACTER(len = 256) 			:: 	flfrc1, flfrc2
	CHARACTER(len = 256) 			:: 	asr
	REAL(KIND = RP), ALLOCATABLE 	::  frc1(:,:,:,:,:,:,:), tau1(:,:),  &
										zeu1(:,:,:), m_loc(:,:)
	INTEGER, ALLOCATABLE  			:: 	ityp1(:)
	REAL(KIND = RP), ALLOCATABLE 	:: 	frc2(:,:,:,:,:,:,:), tau2(:,:),  &
										zeu2(:,:,:)
	REAL(KIND = RP), ALLOCATABLE 	:: 	f_of_q1(:,:,:,:), f_of_q2(:,:,:,:)
	INTEGER, ALLOCATABLE  			:: 	ityp2(:)
	INTEGER 						:: 	nr1, nr2, nr3, nat(2), ibrav(2), ntyp(2)
	LOGICAL 						:: 	has_zstar(2), na_ifc, fd
	REAL(KIND = RP) 				:: 	epsil(3,3,2), alat1, alat2
	REAL(KIND = RP), ALLOCATABLE 	::	amass1(:), amass2(:)
	REAL(KIND = RP) 				:: 	omega1, omega2, q(3), qq, qhat(3)
	REAL(KIND = RP), ALLOCATABLE 	:: 	w2(:)
	COMPLEX(KIND = CP),ALLOCATABLE 	:: 	z(:,:)
	REAL(KIND = RP) 				:: 	at1(3,3), at2(3,3), bg1(3,3)
	INTEGER 						:: 	mode
!	*****************************************************************************************
!	Monkhorst Pack
	LOGICAL 						::	mp, calc_TC, scattered_energy
	INTEGER							::	qpoint, nk1, nk2, nk3, &
										ntetra, nqx, nq
	INTEGER, ALLOCATABLE 			:: 	tetra(:,:)
	REAL(KIND=RP), ALLOCATABLE		::	qlist(:,:)
!	*****************************************************************************************
!	Supercell Variables
	REAL(KIND = RP) 				:: 	at_conv(3,3)
	INTEGER 						:: 	natsc
	REAL(KIND = RP), ALLOCATABLE 	:: 	tausc(:,:), r_cell(:,:)
	INTEGER, ALLOCATABLE 			:: 	itypsc(:)
	COMPLEX(KIND = CP), ALLOCATABLE :: 	zsc(:), zc(:)
	INTEGER, ALLOCATABLE 			:: 	ib_vec1(:,:,:,:,:), ib_vec2(:,:,:,:,:), &
										na_vec(:)
!	*****************************************************************************************
!	FDPML variables
	LOGICAL 						:: 	periodic
	INTEGER 						:: 	natc, yplane, errore
	REAL 							:: 	PD(3), TD(3), center(3), atc(3,3) 
	REAL(KIND = RP), ALLOCATABLE 	:: 	tauc(:,:)
	INTEGER, ALLOCATABLE 			:: 	itypc(:)
	INTEGER, ALLOCATABLE 			:: 	ityp_PD(:,:,:,:), ityp_TD(:,:,:,:), my_ityp_TD(:,:,:,:)
	REAL(KIND = RP), ALLOCATABLE 	:: 	amass_PD(:,:,:,:), amass_TD(:,:,:,:), my_amass_TD(:,:,:,:)
	INTEGER 						:: 	n1, n2, n3, na, i, j, i1, i2, i3, &
										nb, ia, ib, ipol, jpol ! counters
	INTEGER 						:: 	LPML, natoms_PML
	COMPLEX(KIND = CP), ALLOCATABLE :: 	my_uinc(:), my_K(:), my_uscat(:)
	INTEGER 						:: 	ityp
	REAL(KIND = RP) 				:: 	weight, mass1, mass2, sigmamax, vg(3)
	REAL(KIND = RP), ALLOCATABLE 	:: 	wscache(:,:,:,:,:)
	INTEGER 						:: 	m1,m2,m3
	REAL(KIND = RP) 				:: 	IFC(3,3)
	INTEGER 						:: 	Location
	INTEGER(KIND = IP), ALLOCATABLE :: 	ilist(:), jlist(:)
	COMPLEX(KIND = CP), ALLOCATABLE :: 	Alist(:)
	REAL(KIND = RP), ALLOCATABLE	::	sig(:,:)
	REAL(KIND=RP) 					:: 	rws(0:3,nrwsx), atws(3,3)
	INTEGER 						:: 	nrws, my_TD3, TD3_start
	REAL 							:: 	start, finish
!	*****************************************************************************************
!	Local variables
	INTEGER 						:: 	counter
	INTEGER 						:: 	total_connections
	INTEGER(KIND = IP) 				:: 	natoms, my_natoms, rem, my_nrows, nrows, my_nnz
	INTEGER(KIND = IP), ALLOCATABLE :: 	everyones_atoms(:), atoms_start(:), &
										everyones_rows(:)
	INTEGER(KIND = IP) 				:: 	nSub(4), iSub(4)
	INTEGER(KIND = IP) 				:: 	n, p, atom_tuple(4)
	REAL(KIND = RP) 				:: 	r(3), arg, r_ws(3)
	CHARACTER(len = 256) 			:: 	wavetype
!	*****************************************************************************************
!	Plotting variables
	REAL(KIND = RP), ALLOCATABLE 	:: 	my_xplot(:), my_zplot(:), my_uincp(:,:), &
										my_uscatp(:,:), my_sigp(:,:), my_Kp(:,:)
	REAL(KIND = RP), ALLOCATABLE 	:: 	xplot(:), zplot(:), uincp(:,:), uscatp(:,:), &
										sigp(:,:), Kp(:,:)
	INTEGER(KIND = IP)				:: 	counter1,  plottingmode, counter2, &
										my_tatoms_in_yplane, BW, maximum, sig_atoms
	INTEGER(KIND = IP), ALLOCATABLE :: 	borderlogic(:), tatoms_in_yplane(:), &
										rdispls(:)
	REAL 							:: 	plottingplane
	LOGICAL 						:: 	plotting, plot_uinc, plot_uscat, plot_K, &
										plot_sig
	COMPLEX(KIND = CP) 				:: 	uinc_temp(3), uscat_temp(3), sig_temp(3), &
										K_temp(3)
	real(kind = 4) 					:: 	zrange(2)
!	*****************************************************************************************
!	BICG variables
	REAL (KIND = 4), ALLOCATABLE 	:: 	resvec(:)
	REAL (KIND = RP) 				:: 	tol
	INTEGER(KIND = 4) 				:: 	maxit, flag
!	*****************************************************************************************
	REAL(KIND = RP) 				:: Total_time, my_Total_time, Total_mul_time, &
									   my_Total_time_mkl, start_mkl, finish_mkl, Total_time_mkl, &
									   Total_comm_time
	INTEGER							:: my_Total_elements = 0.D0, Total_elements
!	*****************************************************************************************
!	Post Processing
	REAL(KIND = RP) 				::  my_Eleft, my_Eright, Eleft, Eright, &
										Transmission_coefficient, my_Escat, Escat
!	*****************************************************************************************
!	restart variables
	LOGICAL :: restart
	INTEGER :: iterpause
	CHARACTER(len = 256) :: tmp_dir, restartfile, format_string
!	*****************************************************************************************
!	Timing Variables
	REAL							:: 	preprocessing_time, matrix_time, solution_time, postprocessing_time
!	REAL							:: 	my_preprocessing_time, my_matrix_time, my_solution_time, &
!										my_postprocessing_time
	INTEGER(KIND = IP)				:: 	my_BW
	INTEGER							:: 	final_iter
	LOGICAL							::	scattering_Xsec, expense_estimate
	CHARACTER(len = 256) 			::	q_file
	LOGICAL							::	q_from_file
	REAL(KIND = RP), ALLOCATABLE	::	w2list(:,:), qlist_from_file(:,:)
	COMPLEX(KIND = CP), ALLOCATABLE	::	zclist(:,:)
	REAL(KIND =RP)					::	Xsec, Jinc, V
	INTEGER							::	mem_ityp_TD, mem_ityp_PD, mem_amass_PD, mem_amass_TD
	
	CALL mp_init( )
	
	ALLOCATE(everyones_atoms(world_size), atoms_start(world_size), &
			 everyones_rows(world_size), tatoms_in_yplane(world_size), &
			 rdispls(world_size))
	
	CALL MPIvars_init( )
	
!	*****************************************************************************************
!	Read Input

	NAMELIST /filenames/ mass_file, domain_file, flfrc1, flfrc2, mass_input &
			 /system/ simulation_type, PD, LPML, periodic, crystal_coordinates, &
					  asr, wavetype, q, mode, sigmamax, expense_estimate &
			 /qlists/ q_from_file, q_file &
			 /solver/ tol, maxit &
			 /restartoptions/ restart, iterpause, tmp_dir, &
			 /postprocessing/ calc_TC, scattered_energy, scattering_Xsec &
			 /plots/ plot_K, plot_sig, plot_uinc, plot_uscat, plottingmode &
			 /calibrate/ qlist_file, slist_file, Llist_file, Lpoint, spoint, file_input, &
							qpoint
			 
	Call set_defaults(mass_input, crystal_coordinates, asr, qpoint, &
						file_input, qlist_file, slist_file, Llist_file, &
						Lpoint, spoint, tol, maxit, restart, iterpause, calc_TC, &
						scattered_energy, scattering_Xsec, plot_K, plot_sig, plot_uinc, &
						plot_uscat, q_from_file, q_file, expense_estimate)
	
	IF (root_node) THEN
		READ(stdin, filenames)
		READ(stdin, system)
		READ(stdin, qlists)
		READ(stdin, solver)
		READ(stdin, restartoptions)
		READ(stdin, postprocessing)
		READ(stdin, plots)
		READ(stdin, calibrate)
	ENDIF

	CALL MPI_BCAST(mass_file, 256, MPI_CHAR, root_process, comm, ierr)
	CALL MPI_BCAST(domain_file, 256, MPI_CHAR, root_process, comm, ierr)
	CALL MPI_BCAST(flfrc1, 256, MPI_CHAR, root_process, comm, ierr)
	CALL MPI_BCAST(flfrc2, 256, MPI_CHAR, root_process, comm, ierr)
	CALL MPI_BCAST(mass_input, 1, mp_logical, root_process, comm, ierr)
	CALL MPI_BCAST(simulation_type, 256, MPI_CHAR, root_process, comm, ierr)
	CALL MPI_BCAST(PD, 3, MPI_REAL, root_process, comm, ierr)
!	CALL MPI_BCAST(LPML, 1, MPI_INT, root_process, comm, ierr)
	CALL MPI_BCAST(periodic, 1, mp_logical, root_process, comm, ierr)
	CALL MPI_BCAST(crystal_coordinates, 1, mp_logical, root_process, comm, ierr)
	CALL MPI_BCAST(asr, 256, MPI_CHAR, root_process, comm, ierr)
	CALL MPI_BCAST(wavetype, 256, MPI_CHAR, root_process, comm, ierr)
!	CALL MPI_BCAST(q, 3, mp_real, root_process, comm, ierr)
	CALL MPI_BCAST(mode, 1, MPI_INT, root_process, comm, ierr)
!	CALL MPI_BCAST(sigmamax, 1, mp_real, root_process, comm, ierr)
	CALL MPI_BCAST(q_from_file, 1, mp_logical, root_process, comm, ierr)
	CALL MPI_BCAST(q_file, 256, MPI_CHAR, root_process, comm, ierr)
	CALL MPI_BCAST(qpoint, 1, MPI_INT, root_process, comm, ierr)
	CALL MPI_BCAST(calc_TC, 1, mp_logical, root_process, comm, ierr)
	CALL MPI_BCAST(scattered_energy, 1, mp_logical, root_process, comm, ierr)
	CALL MPI_BCAST(plot_K, 1, mp_logical, root_process, comm, ierr)
	CALL MPI_BCAST(plot_sig, 1, mp_logical, root_process, comm, ierr)
	CALL MPI_BCAST(plot_uinc, 1, mp_logical, root_process, comm, ierr)
	CALL MPI_BCAST(plot_uscat, 1, mp_logical, root_process, comm, ierr)
	CALL MPI_BCAST(file_input, 1, mp_logical, root_process, comm, ierr)
	CALL MPI_BCAST(tol, 1, mp_real, root_process, comm, ierr)
	CALL MPI_BCAST(maxit, 1, MPI_INT, root_process, comm, ierr)
	CALL MPI_BCAST(restart, 1, mp_logical, root_process, comm, ierr)
	CALL MPI_BCAST(iterpause, 1, MPI_INT, root_process, comm, ierr)
	CALL MPI_BCAST(tmp_dir, 256, MPI_CHAR, root_process, comm, ierr)
	CALL MPI_BCAST(scattering_Xsec, 1, mp_logical, root_process, comm, ierr)
	CALL MPI_BCAST(expense_estimate, 1, mp_logical, root_process, comm, ierr)
	
	
	IF (my_id .lt. 10) then
		format_string = "(a, a, a, I1, a)"
	ELSEIF (my_id .lt. 100) THEN
		format_string = "(a, a, a, I2, a)"
	ELSE 
		format_string = "(a, a, a, I3, a)"
	ENDIF
	WRITE(restartfile, format_string ) trim(tmp_dir), '/', 'uscat_', my_id, '.save'
	plotting = ((plot_K) .or. (plot_sig) .or. (plot_uinc) .or. (plot_uscat))
	
	
!!	----------------------------------------------------------------------------------------
!	Read qlist, slist, Llist
	IF (root_node) THEN
		IF (file_input) THEN
			WRITE (stdout, '(a)') '	'
			WRITE (stdout, '(a)') '			Reading qlist file'
			OPEN(unit = 11, file = qlist_file, form = 'formatted')
			READ(11, '(I)') nq
			ALLOCATE(qlist_from_file(3,nq))
			DO i = 1, nq
				READ(11, *) qlist_from_file(1,i), qlist_from_file(2,i), qlist_from_file(3,i)
			ENDDO
			CLOSE(unit = 11)
			q = qlist_from_file(:,qpoint)
			OPEN(unit = 11, file = slist_file, form = 'formatted')
			READ(11, '(I)') nq
			ALLOCATE(slist(nq))
			DO i = 1, nq
				READ(11, *) slist(i)
			ENDDO
			CLOSE(unit = 11)
			sigmamax = slist(spoint)
			OPEN(unit = 11, file = Llist_file, form = 'formatted')
			READ(11, '(I)') nq
			ALLOCATE(Llist(nq))
			DO i = 1, nq
				READ(11, *) Llist(i)
			ENDDO
			CLOSE(unit = 11)
			LPML = Llist(Lpoint)
		ENDIF
	ENDIF
	
	IF (root_node) THEN
		IF (mp) THEN
			CALL recips(at1, bg1)
			IF ((nk1.lt.1) .or. (nk2.lt.1) .or. (nk3.lt.1)) THEN
				WRITE(stdout, '(a)') 'nks are not selected for MP grid'
				STOP
			ENDIF
			ntetra = 6 * nk1 * nk2 * nk3
	        nqx = nk1*nk2*nk3
	        ALLOCATE ( tetra(4,ntetra), qlist(3,nqx) )
			CALL gen_qpoints (ibrav(1), at1, bg1, nat(1), tau1, ityp1, nk1, nk2, nk3, &
								ntetra, nqx, nq, qlist, tetra)
			q = qlist(:,qpoint)
			OPEN (unit = 66, file = 'qlist.txt', form = 'formatted')
			WRITE(66, '(I)') nq
			DO i = 1, nq
				WRITE(66, '(3F10.3)') qlist(1, i), qlist(2, i), qlist(3, i)
			ENDDO
		ENDIF
	ENDIF	
	
!!	----------------------------------------------------------------------------------------
	
	CALL MPI_BCAST(LPML, 1, MPI_INT, root_process, comm, ierr)
	CALL MPI_BCAST(sigmamax, 1, mp_real, root_process, comm, ierr)
	
	IF (periodic) THEN
		TD = PD + (/ 0, 0, 2*LPML/)
	ELSE
		TD = PD + (/ 2*LPML, 2*LPML, 2*LPML/)
	ENDIF
	
	CALL MPI_BCAST(TD, 3, MPI_REAL, root_process, comm, ierr)
	
	counter2 = 0
	
!	read force constant files (located io_modules.f90)
	CALL readfc( flfrc1, frc1, tau1, zeu1, m_loc, ityp1, nr1, nr2, nr3, &
				 epsil(:,:,1), nat(1), ibrav(1), alat1, at1, ntyp(1), &
				 amass1, omega1, has_zstar(1) )
	CALL readfc( flfrc2, frc2, tau2, zeu2, m_loc, ityp2, nr1, nr2, nr3, &
				 epsil(:,:,2), nat(2), ibrav(2), alat2, at2, ntyp(2), &
				 amass2, omega2, has_zstar(2) )
				 
	na_ifc = has_zstar(1)
	fd = na_ifc 

	ALLOCATE(w2(3*nat(1)), z(3*nat(1), 3*nat(1)))

	!	Non-analytic part of force-constants
	ALLOCATE(f_of_q1(3,3,nat(1), nat(1)), f_of_q2(3,3,nat(2),nat(2)))

!**
	CALL cpu_time(start)
	
	IF (io_node) THEN
		IF (.not. q_from_file) THEN
			nq = 1
			ALLOCATE(qlist(3, nq))
			qlist(:,1) = q
		ELSE
			WRITE (stdout, '(a)') '	'
			WRITE (stdout, '(a)') '			Reading qlist file'
			OPEN(unit = 11, file = q_file, form = 'formatted')
			READ(11, '(I)') nq
			ALLOCATE(qlist(3,nq))
			DO i = 1, nq
				READ(11, *) qlist(1,i), qlist(2,i), qlist(3,i)
			ENDDO
			CLOSE(unit = 11)
		END IF
	END IF
	
	CALL MPI_BCAST(nq, 1, MPI_INT, root_process, comm, ierr)
	if (.not. io_node) ALLOCATE(qlist(3,nq))
	CALL MPI_BCAST(qlist, 3*nq, mp_real, root_process, comm, ierr)

	ALLOCATE(w2list(3*nat(1), nq))

!**
	CALL cpu_time(start)

!!	----------------------------------------------------------------------------------------

	CALL get_natsc(at1, atc, nat(1), natc, crystal_coordinates)

	ALLOCATE(na_vec(natc))
	ALLOCATE(r_cell(3, natc))
	ALLOCATE (tauc(3,natc), itypc(natc), zc(3*natc))
	ALLOCATE(ib_vec1(nat(1), -2*nr1:2*nr1, -2*nr2:2*nr2, -2*nr3:2*nr3, natc))
	ALLOCATE(ib_vec2(nat(2), -2*nr1:2*nr1, -2*nr2:2*nr2, -2*nr3:2*nr3, natc))
	ALLOCATE(zclist(3*natc, nq))
	
	
	DO qpoint = 1, nq
		q(:) = qlist(:,qpoint)
		! get_disp: see preprocessing_module.f90
		call get_disp(asr, na_ifc, fd, has_zstar, q, alat1, alat2, at1, at2, &
							nat, ntyp, nr1, nr2, nr3, ibrav, mode, ityp1, ityp2, epsil, zeu1, &
							zeu2, vg, omega1, omega2, frc1, frc2, w2, f_of_q1, f_of_q2, amass1, amass2, &
							tau1, tau2, z)
					
	!	----------------------------------------------------------------------------------------
	! 	Deciding whether to work in crystal or primitive coordinates
	!	at_conv are the lattice vectors for convectional unit cell or any other 
	!	supercell. However the Volume(Supercell) = n*Volume(primitive cell)
	!	where n is an integer
	

	
		call get_supercell(at1, tau1, ityp1, nat, z(:,mode), r_cell, na_vec, ib_vec1, &
									ib_vec2, natc, tauc, itypc, atc, zc, crystal_coordinates, &
									nr1, nr2, nr3)
	
		zclist(:,qpoint) = zc(:)
	
	ENDDO
	

	
	sigmamax = sigmamax*sqrt(w2(mode))/(LPML*(q(3)))
	
		
	IF (root_node) THEN
		WRITE (stdout, '(a)') '=================Conventional Units=========================='
		WRITE (stdout, '(a1, a18, F10.3, a, F10.3, a, F10.3)') 	'!',',vg (m/s),', vg(1)*RY_TO_THZ*1.0d12*tpi*alat1*BOHR_RADIUS_SI, &
															',', vg(2)*RY_TO_THZ*1.0d12*tpi*alat1*BOHR_RADIUS_SI, & 
															',', vg(3)*RY_TO_THZ*1.0d12*tpi*alat1*BOHR_RADIUS_SI
		WRITE (stdout, '(a1, a18, F10.3)')	'!',',lambda_inc (nm),', alat1/norm2(q)*BOHR_RADIUS_SI*1d9
		WRITE (stdout, '(a1, a18, F10.3)') 	'!',',LPML (nm),', LPML*alat1*BOHR_RADIUS_SI*1d9
		WRITE (stdout, '(a1, a18, F10.3)')	'!',',sigmamax (THz),', sigmamax*RY_TO_THZ
		WRITE (stdout, '(a1, a18, F10.3)')	'!',',w (THz),', sqrt(w2(mode))*RY_TO_THZ
		WRITE (stdout, '(a)') '============================================================='
	ENDIF

!	========================================================================================
!	Generating the primary and total domain.
!
!	----------------------------------------------------------------------------------------
!	Generate primary domain using gendomain script. The script saves the 
!	domain as a binary.
!
!	Loading the primary domain

	call gen_TD(domain_file, mass_file, my_amass_TD, my_ityp_TD, PD, TD, periodic, ntyp, &
						amass1, amass2, natc, itypc, mass_input, LPML, nr3, my_TD3, TD3_start)

						
!**	
	CALL cpu_time(finish)
	
	preprocessing_time = finish - start
	 
!	========================================================================================= 
	 
!**
	CALL cpu_time(start)

!	=========================================================================================
	
	call get_nrows(natoms, my_natoms, rem, my_nrows, nrows, everyones_atoms, &
						atoms_start, everyones_rows, TD, natc)
						

!	=========================================================================================
!	Generate Incident wave

	nSub = (/ natc, int(TD(1)), int(TD(2)), int(TD(3)) /)
	
	call gen_uinc(natc, nSub, my_natoms, my_nrows, zclist, wavetype, my_uinc, atoms_start, &
						atc, r_cell, LPML, qlist, nq)
						
!	=======================================================================================
!	Generating the damping coefficients

	CALL gen_sig(sig, my_natoms, sigmamax, LPML, periodic, atc, atom_tuple, &
						TD, PD, atoms_start, my_ityp_TD, tauc, natc, my_TD3, nr3, TD3_start)

!	=======================================================================================


!	----------------------------------------------------------------------------------------
!	Copied as is from qunatum espresso
!	Please refer FAQ page on qunatum-espresso (phonon section, question 7.7)
!	link: http://www.quantum-espresso.org/resources/faq/phonons


	ALLOCATE(wscache(-2*nr3:2*nr3, -2*nr2:2*nr2, -2*nr1:2*nr1, nat(1), nat(1)))

		atws(:,1) = at1(:,1)*DBLE(nr1)
		atws(:,2) = at1(:,2)*DBLE(nr2)
		atws(:,3) = at1(:,3)*DBLE(nr3)
		! initialize WS r-vectors
		CALL wsinit(rws,nrwsx,nrws,atws)

	counter = 0
	DO na=1, nat(1)
		DO nb=1, nat(1)
		!
			DO n1=-2*nr1,2*nr1
				DO n2=-2*nr2,2*nr2
					DO n3=-2*nr3,2*nr3
						DO i=1, 3
							r(i) = n1*at1(i,1)+n2*at1(i,2)+n3*at1(i,3)
							r_ws(i) = r(i) + tau1(i,na)-tau1(i,nb)
							if (fd) r_ws(i) = r(i) + tau1(i,nb)-tau1(i,na)
						END DO
						wscache(n3,n2,n1,nb,na) = wsweight(r_ws,rws,nrws)
						IF (wscache(n3,n2,n1,nb,na).gt.0.D0) THEN
							counter = counter + 1 
						ENDIF	
					ENDDO
				ENDDO
			ENDDO
		ENDDO
	ENDDO
	
	CALL MPI_BCAST(wscache, ((4*nr1+1)*(4*nr2+1)*(4*nr3+1)*nat(1)*nat(2)), mp_real, root_process, comm, ierr)
!	----------------------------------------------------------------------------------------



!	Counter loop to find how much memory is needed for Alist, ilist and jlist
	counter1 = 0	!	counter for ilist, jlist and Alist
	counter2 = 0	!	counter for atoms connected ouside the domain
!	CALL cpu_time(start)
	DO p = 1, my_natoms
		n = p + atoms_start(my_id+1)
		atom_tuple = ind2sub(n, nSub)
		ia = atom_tuple(1)
		i1 = atom_tuple(2)
		i2 = atom_tuple(3)
		i3 = atom_tuple(4) - TD3_start
		ityp = my_ityp_TD(ia, i1, i2, i3)
		na = na_vec(ia)
		IF (ityp.eq.1) THEN
			DO n1 = -2*nr1,2*nr1
				DO n2 = -2*nr2,2*nr2
					DO n3 = -2*nr3,2*nr3
						DO nb = 1, nat(1)
							weight = wscache(n3,n2,n1,nb,na)
							IF (weight.gt.0) THEN
!								Please refer QE link provide above wsweights to 
!								understand m1, m2, m3
								m1 = MOD(n1+1,nr1)
								IF(m1.LE.0) m1=m1+nr1
								m2 = MOD(n2+1,nr2)
								IF(m2.LE.0) m2=m2+nr2
								m3 = MOD(n3+1,nr3)
								IF(m3.LE.0) m3=m3+nr3
								r = (i1-1)*atc(:,1) + (i2-1)*atc(:,2) + &
									(i3 + TD3_start - 1)*atc(:,3)
								r = r + r_cell(:,ia) + n1*at1(:,1) + n2*at1(:,2) + &
									n3*at1(:,3)+ tau1(:,nb)
								r = floor(r)
								ib = ib_vec1(nb,n3,n2,n1,ia) !	Defined in supercell 
															 !	routine
								IF (ib.eq.-1) THEN
									WRITE (stdout, '(a)') 'ERROR : wrong ib'
									STOP
								ENDIF
!								Apply periodic boundaries
								IF (periodic) THEN
									r(1)= MOD(r(1),(TD(1)-1))
	                                IF (r(1).lt.0) THEN
										r(1)=r(1)+TD(1)-1
									ENDIF
									r(2)= MOD(r(2),(TD(2)-1))
									IF (r(2).lt.0) THEN
										r(2)=r(2)+TD(2)-1
									ENDIF
								ENDIF
!								If the connecting atom is outside TD, then skip loop								
								IF ((r(1).lt.0) .or. (r(2).lt.0) .or. &
									(r(3).lt.0) .or. (r(1).gt.(TD(1)-1)) .or. &
									(r(2).gt.(TD(2)-1)) .or. (r(3).gt.(TD(3)-1))) THEN
									DO i = 1, 3
										counter2 = counter2+1
									ENDDO
									CYCLE
								ENDIF
								DO ipol = 1,3
									DO jpol = 1,3
										counter1 = counter1 + 1
										IF (counter1.eq.huge(counter1)) THEN
											WRITE(stdout, '(a, a, I4)') &
											'Size of Amat is larger',& 
											'than that is allowed by int kind', IP
											STOP
										ENDIF
									ENDDO
								ENDDO
							ENDIF
						ENDDO
					ENDDO
				ENDDO
			ENDDO
		ELSEIF (ityp.eq.2) THEN
!		This loop is identical to loop above ityp == 1. It only accounts 
!		for a change in lattice cell type for material 2
			DO n1 = -2*nr1,2*nr1
				DO n2 = -2*nr2,2*nr2
					DO n3 = -2*nr3,2*nr3
						DO nb = 1, nat(2)
							weight = wscache(n3,n2,n1,nb,na)
							IF (weight.gt.0) THEN
								m1 = MOD(n1+1,nr1)
								IF(m1.LE.0) m1=m1+nr1
								m2 = MOD(n2+1,nr2)
								IF(m2.LE.0) m2=m2+nr2
								m3 = MOD(n3+1,nr3)
								IF(m3.LE.0) m3=m3+nr3
								r = (i1-1)*atc(:,1) + (i2-1)*atc(:,2) + &
									(i3 + TD3_start - 1)*atc(:,3)
								r = r + r_cell(:,ia) + n1*at2(:,1) + n2*at2(:,2) + &
									n3*at2(:,3)+ tau2(:,nb)
								r = floor(r)
								ib = ib_vec2(nb,n3,n2,n1,ia)
								IF (ib.eq.-1) THEN
									WRITE (stdout, '(a)') 'ERROR : wrong ib'
									STOP
								ENDIF
								IF (periodic) THEN
									r(1)= MOD(r(1),(TD(1)-1))
	                                IF (r(1).lt.0) THEN
										r(1)=r(1)+TD(1)-1
									ENDIF
									r(2)= MOD(r(2),(TD(2)-1))
									IF (r(2).lt.0) THEN
										r(2)=r(2)+TD(2)-1
									ENDIF
								ENDIF
								IF ((r(1).lt.0) .or. (r(2).lt.0) .or. &
									(r(3).lt.0) .or. (r(1).gt.(TD(1)-1)) .or. &
									(r(2).gt.(TD(2)-1)) .or. (r(3).gt.(TD(3)-1))) THEN
									DO i = 1, 3
										counter2 = counter2+1
									ENDDO
									CYCLE
								ENDIF
								DO ipol = 1,3
									DO jpol = 1,3
										counter1 = counter1 + 1
										IF (counter1.eq.huge(counter1)) THEN
											WRITE(stdout, '(a, a, I4)') &
											'Size of Amat is larger',& 
											'than that is allowed by int kind', IP
											STOP
										ENDIF
									ENDDO
								ENDDO
							ENDIF
						ENDDO
					ENDDO
				ENDDO
			ENDDO
		ENDIF	
	ENDDO
	
	
!	sig_atoms accounts for the total number of nnz needed for adding the sigma elements 
!	to Amat
	
!	IF (periodic) THEN
!		sig_atoms = 2*(LPML)*int(PD(1))*int(PD(2))*natc
!	ELSE
!		sig_atoms = (int(TD(1))*int(TD(2))*int(TD(3)) - &
!						int(PD(1))*int(PD(2))-int(PD(3)))*natc 
!	END IF
	
	DO p = 1, my_natoms
		DO ipol = 1,3
			IF (sig(p,ipol).eq.0.D0) THEN
				CYCLE
			ELSE
				counter1 = counter1 + 1
				IF (counter1.eq.huge(counter1)) THEN
					WRITE(stdout, '(a, a, I4)') &
						'Size of Amat is larger',& 
						'than that is allowed by int kind', IP
					STOP
				ENDIF
			ENDIF
		ENDDO
	ENDDO
!	----------------------------------------------------------------------------------------

	my_nnz = counter1+my_nrows
	
	
!	memory = memory(ilist) + memory(jlist) + memory(Alist) + memory(uinc) + memory(uscat) +&
!			memory(ityp_PD) + memory(ityp_PD) + memory(amass_PD) + memory(amass_TD) + memory(sig) + &
!			memory(my_K) + memory(borderlogic)

	mem_ityp_PD = sizeof(ityp_PD)
	mem_ityp_TD = sizeof(ityp_TD)
	mem_amass_PD = sizeof(amass_PD)
	mem_amass_TD = sizeof(my_amass_TD)
	CALL print_memory_usage(my_nnz, my_nrows, nrows, counter2, mem_ityp_PD, mem_ityp_TD, &
								mem_amass_TD, mem_amass_PD)

	CALL MPI_BARRIER(comm, ierr)
	
	
	IF (expense_estimate) THEN
		CALL mp_finalize( )
		if (io_node) WRITE (stdout, '(a)') 'Ending memory calculation run'
		STOP
	ENDIF
	
!	Set up A-matrix

	IF (io_node) write (stdout, *) '	'
	IF (io_node) write (stdout, *) '-----------------------------------------------------------------------'
	IF (io_node) write (stdout, *) 'Setting up A matrix'


	
	ALLOCATE(	ilist(counter1+my_nrows), jlist(counter1+my_nrows), &
				Alist(counter1+my_nrows), stat = ierr	) ! my_nrows accounts for -m*w**2 
											  ! subtraction from every row of A-mat
											  ! Amat = -(m*w**2+K) equn A3 on 
											  !	PHYSICAL REVIEW B 95, 125434 (2017)


	IF (ierr.ne.0) THEN
		WRITE (stdout, '(a)') 'ERROR ALLOCATING MEMORY'
	ENDIF 


	ALLOCATE(borderlogic(counter2))		  ! Defines every atom connected outside
											  ! TD
	
	counter1 = 0
	counter2 = 0
	
	my_BW = 0

	DO p = 1, my_natoms
		n = p + atoms_start(my_id+1)
		atom_tuple = ind2sub(n, nSub)
		ia = atom_tuple(1)
		i1 = atom_tuple(2)
		i2 = atom_tuple(3)
		i3 = atom_tuple(4) - TD3_start
		ityp = my_ityp_TD(ia, i1, i2, i3)
		na = na_vec(ia)
		IF (ityp.eq.1) THEN
			DO n1 = -2*nr1,2*nr1
				DO n2 = -2*nr2,2*nr2
					DO n3 = -2*nr3,2*nr3
						DO nb = 1, nat(1)
							weight = wscache(n3,n2,n1,nb,na)
							IF (weight.gt.0) THEN
								m1 = MOD(n1+1,nr1)
								IF(m1.LE.0) m1=m1+nr1
								m2 = MOD(n2+1,nr2)
								IF(m2.LE.0) m2=m2+nr2
								m3 = MOD(n3+1,nr3)
								IF(m3.LE.0) m3=m3+nr3
								r = (i1-1)*atc(:,1) + (i2-1)*atc(:,2) + &
									(i3 + TD3_start -1)*atc(:,3)
								r = r + r_cell(:,ia) + n1*at1(:,1) + n2*at1(:,2) + &
									n3*at1(:,3)+ tau1(:,nb)
								r = floor(r)
								ib = ib_vec1(nb,n3,n2,n1,ia)
								IF (periodic) THEN
									r(1)= MOD(r(1),(TD(1)-1))
	                                IF (r(1).lt.0) THEN
										r(1)=r(1)+TD(1)-1
									ENDIF
									r(2)= MOD(r(2),(TD(2)-1))
									IF (r(2).lt.0) THEN
										r(2)=r(2)+TD(2)-1
									ENDIF
								ENDIF
								IF ((r(1).lt.0) .or. (r(2).lt.0) .or. &
									(r(3).lt.0) .or. (r(1).gt.(TD(1)-1)) .or. &
									(r(2).gt.(TD(2)-1)) .or. (r(3).gt.(TD(3)-1))) THEN
!								IF the atom is connected outside the domain then
!								record it.
									DO i = 1,3
										counter2 = counter2 + 1
										borderlogic(counter2) = 3*p - (3-i)
									ENDDO
									CYCLE
								ENDIF
								isub = (/ ib, int(r(1))+1, int(r(2))+1, &
										int(r(3))+1 /)
										
!								Location defines the location in uinc for 
!								(n1, n2, n3, nb) atom. 
!								Location essentially defines the column number in A

								Location = sub2ind(iSub, nSub) ! transform 3-D space 
															   ! to 1-D

								mass1 = my_amass_TD(ia, i1, i2, i3)
								mass2 = my_amass_TD(ib, int(r(1))+1,int(r(2))+1,&
												 int(r(3))+1 - TD3_start)
!								mass1 = amass1(ityp2(na))
!								IF (ityp_TD(int(r(1))+1, int(r(2))+1, &
!											int(r(3))+1, ib).eq.2) THEN
!									mass2 = amass2(ityp2(nb))
!								ELSEIF (ityp_TD(int(r(1))+1, int(r(2))+1, &
!												int(r(3))+1, ib).eq.1) THEN
!									mass2 = amass1(ityp1(nb))
!								ENDIF
!								Adding non-analytic part of FCs 
								IFC = (frc1(m1,m2,m3,:,:,na,nb)+f_of_q1(:,:,na,nb))
								DO ipol = 1,3
									DO jpol = 1,3
										counter1 = counter1 + 1
										ilist(counter1) = 3*n-(3-ipol)
	                                    jlist(counter1) = 3*Location-(3-jpol)
										Alist(counter1) = IFC(ipol,jpol)* &
														  weight/(amu_ry* &
														  sqrt(mass1*mass2)* &
														  w2(mode))
										my_BW = maximum(BW, KIABS((ilist(counter1)-jlist(counter1))))				  
										IF ((sqrt(mass1*mass2).eq.0.D0) .or. &
											(w2(mode).eq.0.D0)) THEN
											print *, 'HELLO'
											EXIT
										ENDIF
									ENDDO
								ENDDO
							ENDIF
						ENDDO
					ENDDO
				ENDDO
			ENDDO
		ELSEIF (ityp.eq.2) THEN
!		Identical loop as above but accouting for lattice type of material 2
			DO n1 = -2*nr1,2*nr1
				DO n2 = -2*nr2,2*nr2
					DO n3 = -2*nr3,2*nr3
						DO nb = 1, nat(2)
							weight = wscache(n3,n2,n1,nb,na)
							IF (weight.gt.0) THEN
								m1 = MOD(n1+1,nr1)
								IF(m1.LE.0) m1=m1+nr1
								m2 = MOD(n2+1,nr2)
								IF(m2.LE.0) m2=m2+nr2
								m3 = MOD(n3+1,nr3)
								IF(m3.LE.0) m3=m3+nr3
								r = (i1-1)*atc(:,1) + (i2-1)*atc(:,2) + &
									(i3 + TD3_start -1)*atc(:,3)
								r = r + r_cell(:,ia) + n1*at2(:,1) + n2*at2(:,2) + &
									n3*at2(:,3)+ tau2(:,nb)
								r = floor(r)
								ib = ib_vec2(nb,n3,n2,n1,ia)
								IF (periodic) THEN
									r(1)= MOD(r(1),TD(1)-1)
	                                IF (r(1)<0) THEN
										r(1)=r(1)+TD(1)-1
									ENDIF
									r(2)= MOD(r(2),TD(2)-1)
									IF (r(2)<0) THEN
										r(2)=r(2)+TD(2)-1
									ENDIF
								ENDIF
								IF ((r(1).lt.0) .or. (r(2).lt.0) .or. &
									(r(3).lt.0) .or. (r(1).gt.(TD(1)-1)) .or. &
									(r(2).gt.(TD(2)-1)) .or. (r(3).gt.(TD(3)-1))) THEN
									DO i = 1,3
										counter2 = counter2 + 1
										borderlogic(counter2) = 3*p - (3-i)
									ENDDO
									CYCLE
								ENDIF
								isub = (/ ib, int(r(1))+1, int(r(2))+1, &
											int(r(3))+1 /)
								Location = sub2ind(iSub, nSub)
								mass1 = my_amass_TD(ia, i1, i2, i3)
								mass2 = my_amass_TD(ib, int(r(1))+1,int(r(2))+1,&
												 int(r(3))+1 - TD3_start)
!								mass1 = amass2(ityp2(na))
!								IF (ityp_TD(int(r(1))+1, int(r(2))+1, &
!											int(r(3))+1, ib).eq.2) THEN
!									mass2 = amass2(ityp2(nb))
!								ELSEIF (ityp_TD(int(r(1))+1, int(r(2))+1, &
!												int(r(3))+1, ib).eq.1) THEN
!									mass2 = amass1(ityp1(nb))
!								ENDIF
								IFC = (frc2(m1,m2,m3,:,:,na,nb)+f_of_q2(:,:,na,nb))
								DO ipol = 1,3
									DO jpol = 1,3
										counter1 = counter1 + 1
										ilist(counter1) = 3*n-(3-ipol)
	                                    jlist(counter1) = 3*Location-(3-jpol)
	                                    
	                                    my_BW = maximum(BW, KIABS((ilist(counter1)-jlist(counter1))))
										Alist(counter1) = IFC(ipol,jpol)* &
														  weight/(amu_ry* &
														  sqrt(mass1*mass2)* &
														  w2(mode))
														  
										IF ((sqrt(mass1*mass2).eq.0.D0) .or. &
											(w2(mode).eq.0.D0)) THEN
											print *, 'HELLO'
											EXIT
										ENDIF
									ENDDO
								ENDDO
							ENDIF
						ENDDO
					ENDDO
				ENDDO
			ENDDO
		ENDIF	
	ENDDO
	
!	CALL MPI_REDUCE(my_BW, BW, 1, mp_int, mp_maxi, root_node, comm, ierr)
	
!	IF (io_node) THEN
!		WRITE (stdout, '(a, I)') 'Bandwidth(A)  = ', BW
!	END IF
!	Adding -m*w**2 part after normalizing by m*w**2. So adding -1 :-P
	DO p = 1, my_natoms
		n = p + atoms_start(my_id+1)
		DO ipol = 1,3
			counter1 = counter1+1
			ilist(counter1) = 3*n-(3-ipol)
			jlist(counter1) = 3*n-(3-ipol)
			Alist(counter1) = CMPLX(-1.0, 0.0, KIND = CP)
		ENDDO
	ENDDO
	
	Alist(:) = CMPLX(-1.0, 0.0, kind = CP)*Alist(:)
		
	IF (io_node) WRITE (stdout, *) '	'
	IF (io_node) WRITE (stdout, *) 'DONE'

	CALL cpu_time(finish)
	
	
!	==========================================================================================
!	Calculate the RHS of linear algebra problem AU = K
!	CALL cpu_time(start)
	calc_scounts_n = .true.
	
	ALLOCATE(my_K(my_nrows))
	
	CALL matvectcoo(Alist(1:counter1), ilist(1:counter1), jlist(1:counter1), &
					counter1, my_uinc, my_K, my_nrows, everyones_rows, 'N')
	
!	CALL cpu_time(finish)
		
!	Hard-wall boundary conditions
	DO i = 1, counter2
		my_K(borderlogic(i)) = CMPLX(0.0, 0.0, KIND = CP)
	ENDDO
	

!	==========================================================================================

!	******************************************************************************************
!	Integrating damping coefficients into A-matrix
	DO p = 1, my_natoms
		n = p + atoms_start(my_id+1)
		DO ipol = 1,3
			IF (sig(p,ipol).eq.0.D0) THEN
				CYCLE
			ELSE
				counter1 = counter1 + 1
				ilist(counter1) = 3*n-(3-ipol)
				jlist(counter1) = 3*n-(3-ipol)
				Alist(counter1) = CMPLX(sig(p,ipol)/sqrt(w2(mode)), 0.0_RP, KIND = CP)**2 - &
											2*CMPLX(0.0_RP, 1.0_RP, KIND = CP) * &
											CMPLX(sig(p,ipol)/sqrt(w2(mode)), 0.0_RP, KIND = CP)
			ENDIF
		ENDDO
	ENDDO
	
!**
	CALL cpu_time(finish)
	
	matrix_time = finish - start
	

	
!	OPEN (unit = 666, file = 'Alist.txt', form = 'formatted')
	
!	DO i = 1, my_nnz
!		WRITE(666, '(2I7, 2E14.7)') ilist(i), jlist(i), real(Alist(i)), aimag(Alist(i))
!	ENDDO
	
!	CLOSE(666)
	
!	OPEN (unit = 666, file = 'K.txt', form = 'formatted')
	
!	DO i = 1, my_nnz
!		WRITE(666, '(2E14.7)') real(my_K(i)), aimag(my_K(i))
!	ENDDO
	
!	CLOSE(666)
	
!	STOP

!	******************************************************************************************


	ALLOCATE(resvec(2*maxit+1))
	ALLOCATE(my_uscat(my_nrows))
	
	IF (restart) THEN
		open (unit  = 639, file = restartfile, form = 'unformatted')
		read (unit = 639) my_uscat
		close(unit = 639)
	ENDIF
	
	natoms_PML = PD(1)*PD(2)*LPML

	tol = tol*(real(natoms_PML))
	WRITE(stdout, *) tol

!**
	CALL cpu_time(start)
	start_mkl = dsecnd()
	CALL mpibicgstabcoo (	Alist, ilist, jlist, my_uscat, my_K, my_nnz, &
						my_nrows, nrows, everyones_rows, tol, maxit, resvec, flag, &
						iterpause, restartfile	)
						
	CALL MPI_BARRIER(comm, ierr)
	OPEN(unit = 639, file = restartfile, form = 'unformatted')
	WRITE(639) my_uscat
	CLOSE(unit = 639)
	
	finish_mkl = dsecnd()
!**				
	CALL cpu_time(finish)
	
	my_Total_time = finish - start
	
	solution_time = my_Total_time
	
	my_Total_time_mkl = finish_mkl - start_mkl
	
	CALL MPI_REDUCE(my_Total_time, Total_time, 1, mp_real, mp_sumr, root_process, &
					comm, ierr)
	CALL MPI_REDUCE(my_Total_time_mkl, Total_time_mkl, 1, mp_real, mp_sumr, &
					root_process, comm, ierr)
	CALL MPI_REDUCE(my_Total_comm_mkl, Total_comm_time, 1, mp_real, mp_sumr, &
					root_process, comm, ierr)
	
	final_iter = 0			
	DO i = 1, 2*maxit+1
		IF (abs(resvec(i)) .lt. 1e-8) THEN
			EXIT
		END IF
		
		final_iter = i
	END DO
	
		
	
!	*********************************************************************************************

!**

	CALL cpu_time(start)

!	=============================================================================================
!	POST-PROCESSING
!	
!	Tranmission Coefficient
!
!
	IF (calc_TC) THEN
		my_Eleft = 0.0_RP
		my_Eright = 0.0_RP
		DO p = 1, my_natoms
			n = p + atoms_start(my_id+1)
			atom_tuple = ind2sub(n, nSub)
			ia = atom_tuple(1)
			i1 = atom_tuple(2)
			i2 = atom_tuple(3)
			i3 = atom_tuple(4) - TD3_start
			ityp = my_ityp_TD(ia, i1, i2, i3)
			na = na_vec(ia)
			IF (i3.lt.(TD(3)/2.D0)) THEN
				DO ipol = 1,3
					my_Eleft= my_Eleft + abs(sig(p,ipol))* &
									abs(my_uscat(3*p-(3-ipol)))**2
				ENDDO
			ELSEIF (i3.gt.(TD(3)/2.D0)) THEN
				DO ipol = 1,3
					my_Eright= my_Eright + abs(sig(p,ipol))* &
									abs(my_uscat(3*p-(3-ipol)))**2
				ENDDO
			ENDIF
		ENDDO
		CALL MPI_REDUCE(my_Eleft, Eleft, 1, mp_real, mp_sumr, root_process, comm, ierr)
		CALL MPI_REDUCE(my_Eright, Eright, 1, mp_real, mp_sumr, root_process, comm, ierr)

		Transmission_coefficient = Eright/(Eleft+Eright)
	ENDIF
	
	! IF (flag.eq.1) THEN
		! Transmission_coefficient = 0
	! ENDIF
	
!	------------------------------------------------------------------------------------------

!	Scattered Energy
!

	IF (scattered_energy) THEN
		my_Escat = 0.0
		DO p = 1, my_natoms
			n = p + atoms_start(my_id+1)
			atom_tuple = ind2sub(n, nSub)
			ia = atom_tuple(1)
			i1 = atom_tuple(2)
			i2 = atom_tuple(3)
			i3 = atom_tuple(4) - TD3_start
			ityp = my_ityp_TD(ia, i1, i2, i3)
			na = na_vec(ia)
			IF (ityp.eq.1) THEN
				DO ipol = 1,3
					my_Escat = my_Escat + abs(sig(p,ipol))* &
											abs(my_uscat(3*p-(3-ipol)))**2
				ENDDO
			ENDIF
			IF (ityp.eq.2) THEN
				DO ipol = 1,3
					my_Escat = my_Escat + abs(sig(p,ipol))* &
											abs(my_uscat(3*p-(3-ipol)))**2
				ENDDO
			ENDIF
		ENDDO
	ENDIF
	
	CALL MPI_REDUCE(my_Escat, Escat, 1, mp_real, mp_sumr, root_process, comm, ierr)

	IF (flag.eq.1) THEN
		Escat = 0.0
	ENDIF

	CALL cell_volume(at1, 1.D0, V)
	
	IF (io_node) THEN
		IF (scattering_Xsec) THEN
			Jinc = nrm2(vg)/(V*nat(1))*nrm2(abs(z(:,mode)))**2
			print *, Jinc*TD(1)*TD(2)/Escat
			Xsec = Escat/Jinc
		ENDIF 
	ENDIF

!	******************************************************************************************

!**
	CALL cpu_time(finish)
	
	postprocessing_time = finish - start
	
!	IF (io_node) THEN
!		open(1, file = timing_file, status = 'new') 
!	END IF
	
!	CALL print_time(preprocessing_time, matrix_time, solution_time, postprocessing_time, &
!						PD, nrows, natoms, 1, final_iter, Transmission_coefficient, counter2)

!	******************************************************************************************

!	Beta phase testing
!	Properties I believe that affect the PML parameters
!
!
	IF (root_node) THEN
		WRITE (stdout, '(a)') '============================================================='
		WRITE (stdout, '(a, E10.3, a, E10.3, a, E10.3)') 	'!,vg,', vg(1), ',', vg(2), ',', vg(3)
		WRITE (stdout, '(a, E10.3, a, E10.3, a, E10.3)')	'!,q,', q(1), ',', q(2), ',', q(3)
		WRITE (stdout, '(a, I10)') 		'!,LPML,', LPML
		WRITE (stdout, '(a, E10.3)')	'!,sigmamax,', sigmamax
		WRITE (stdout, '(a, E10.3)')	'!,w2,', w2(mode)
		WRITE (stdout, '(a, E17.10)')	'!,T,', Transmission_coefficient
		WRITE (stdout, '(a, E17.10)')	'!,Total_E,', (Eright + Eleft)
		WRITE (stdout, '(a, E17.10)')	'!Escat', Escat
		WRITE (stdout, '(a, F10.3)')	'!,Time,', Total_time/(world_size)
		WRITE (stdout, '(a)') '============================================================='
	ENDIF

	
!	******************************************************************************************

!	=========================================================================================

!	IF plotting is true. Generate a plot of incident wave for atoms on 
!	the plottingplane
!	The plottingplane variable is set to TD(2)/2, so that the obtianed
!	cross-section is a central C/S of the domain

	IF (plotting) THEN
		plottingplane = TD(2)/2 ! plotting a y-crosssectional plane passing 
								! through the center of the domain
		my_tatoms_in_yplane = 0
!		counter loop
		DO p = 1, my_natoms
			yplane = plottingplane
			n = p + atoms_start(my_id+1)
			atom_tuple = ind2sub(n, nSub)
			na = atom_tuple(1)
			n1 = atom_tuple(2)
			n2 = atom_tuple(3)
			n3 = atom_tuple(4)
			r = (n1-1)*atc(:,1) + (n2-1)*atc(:,2) + (n3-1)*atc(:,3) + tauc(:,na)
			IF (abs(r(2) - yplane).lt.1e-2) THEN
				my_tatoms_in_yplane = my_tatoms_in_yplane + 1
			ENDIF
		ENDDO
		
		ALLOCATE(	my_xplot(my_tatoms_in_yplane), my_zplot(my_tatoms_in_yplane), &
					my_uincp(3, my_tatoms_in_yplane), my_uscatp(3, my_tatoms_in_yplane), &
					my_sigp(3, my_tatoms_in_yplane), my_Kp(3, my_tatoms_in_yplane))
		
		counter = 0
		DO p = 1, my_natoms
			yplane = plottingplane
			n = p + atoms_start(my_id+1)
			atom_tuple = ind2sub(n, nSub)
			na = atom_tuple(1)
			n1 = atom_tuple(2)
			n2 = atom_tuple(3)
			n3 = atom_tuple(4)
			r = (n1-1)*atc(:,1) + (n2-1)*atc(:,2) + (n3-1)*atc(:,3) + tauc(:,na)
			DO i = 1,3
				uinc_temp(i) = my_uinc(3*p-(3-i))
				uscat_temp(i) = my_uscat(3*p-(3-i))
				IF (plot_sig) sig_temp(i) = sig(p,i)
				K_temp(i) = my_K(3*p-(3-i))
			ENDDO 
			IF (abs(r(2) - yplane).lt.1e-2) THEN
				counter = counter + 1
				my_xplot(counter) = r(1)
				my_zplot(counter) = r(3)
				DO i = 1, 3
					my_uincp(i, counter) = real(abs(uinc_temp(i)), KIND = RP)
					my_uscatp(i, counter) = real(abs(uscat_temp(i)), KIND = RP)
					my_sigp(i, counter) = real(abs(sig_temp(i)), KIND = RP)
					my_Kp(i, counter) = real(abs(K_temp(i)), KIND = RP)
				ENDDO
			ENDIF
		ENDDO
		
		tatoms_in_yplane(:) = 0.D0
		
!		Now gather all the atoms on yplane onto the root_process. And call the 
!		plotting routine
		CALL MPI_GATHER(my_tatoms_in_yplane, 1, mp_int, &
						tatoms_in_yplane, 1, mp_int, root_process, comm, ierr)
	
		CALL calculate_displs(tatoms_in_yplane, rdispls)
		
		IF (io_node) THEN
			ALLOCATE(xplot(sum(tatoms_in_yplane)), zplot(sum(tatoms_in_yplane)))
		ENDIF
					
		CALL MPI_GATHERV(my_xplot, int(my_tatoms_in_yplane, KIND = 4), mp_real, &
						 xplot, int(tatoms_in_yplane, KIND = 4), &
						 int(rdispls, KIND= 4), mp_real, root_process, comm, ierr)
						
		CALL MPI_GATHERV(my_zplot, int(my_tatoms_in_yplane, KIND = 4), mp_real, &
						 zplot, int(tatoms_in_yplane, KIND = 4), &
						 int(rdispls, KIND = 4), mp_real, root_process, comm, ierr)
			
		IF (plot_uinc) THEN	
			IF (io_node) THEN
				ALLOCATE(uincp(3, sum(tatoms_in_yplane)))
			ENDIF
			CALL MPI_GATHERV(my_uincp, 3*int(my_tatoms_in_yplane, KIND = 4), mp_real, &
						 uincp, 3*int(tatoms_in_yplane, KIND = 4), &
						 3*int(rdispls, KIND = 4), mp_real, root_process, comm, ierr)
		ENDIF
		
		IF (plot_uscat) THEN	
			IF (io_node) THEN
				ALLOCATE(uscatp(3, sum(tatoms_in_yplane)))
			ENDIF
			CALL MPI_GATHERV(my_uscatp, 3*int(my_tatoms_in_yplane, KIND = 4), mp_real, &
						 uscatp, 3*int(tatoms_in_yplane, KIND = 4), &
						 3*int(rdispls, KIND = 4), mp_real, root_process, comm, ierr)
		ENDIF
		
		IF (plot_sig) THEN
			IF (io_node) THEN
				ALLOCATE(sigp(3, sum(tatoms_in_yplane)))
			ENDIF
			CALL MPI_GATHERV(my_sigp, 3*int(my_tatoms_in_yplane, KIND = 4), mp_real, &
						 sigp, 3*int(tatoms_in_yplane, KIND = 4), &
						 3*int(rdispls, KIND = 4), mp_real, root_process, comm, ierr)
		ENDIF
		
		IF (plot_K) THEN
			IF (io_node) THEN
				ALLOCATE(Kp(3, sum(tatoms_in_yplane)))
			ENDIF
			CALL MPI_GATHERV(my_Kp, 3*int(my_tatoms_in_yplane, KIND = 4), mp_real, &
						 Kp, 3*int(tatoms_in_yplane, KIND = 4), &
						 3*int(rdispls, KIND = 4), mp_real, root_process, comm, ierr)
		ENDIF 
		
		IF (root_node) THEN
			
			write(stdout, '(a)') '	'
			write(stdout, '(a, I3)') 'Calling plotting routine on node ', my_id
			
			IF (plot_uinc) THEN
				zrange = (/ 1.1*minval(real(uincp(mode,:))), &
							1.1*maxval(real(uincp(mode, :)))/)
			
				call plot3d(xplot, zplot, real(uincp(mode, :), kind = 8), terminal='ps', &
							filename = 'uinc_plot', persist = 'no')
			ENDIF
		
		ENDIF
		
		CALL MPI_BARRIER(comm, ierr)

		IF (io_node) THEN	
			IF (plot_uscat) THEN
				zrange = (/ 1.1*minval(real(uscatp(mode,:))), &
							1.1*maxval(real(uscatp(mode, :)))/)
			
				call plot3d(xplot, zplot, real(uscatp(mode, :), kind = 8), terminal='ps', &
							filename = 'uscat_plot', persist = 'no')
			ENDIF
		ENDIF
		
		CALL MPI_BARRIER(comm, ierr)

		IF (io_node) THEN
			IF (plot_sig) THEN
				zrange = (/ 1.1*minval(real(sigp(mode,:))), &
							1.1*maxval(real(sigp(mode, :)))/)
			
				call plot3d(xplot, zplot, real(sigp(mode, :), kind = 8), terminal='ps', &
							filename = 'sig_plot', persist = 'no')
			ENDIF
		ENDIF
			
		CALL MPI_BARRIER(comm, ierr)

		IF (io_node) THEN
			IF (plot_K) THEN
				zrange = (/ 1.1*minval(real(Kp(mode,:))), &
							1.1*maxval(real(Kp(mode, :)))/)
			
				call plot3d(xplot, zplot, real(Kp(mode, :), kind = 8), terminal='ps', &
							filename = 'K_plot', persist = 'no')
			ENDIF
		ENDIF


	ENDIF
	
	
!	========================================================================================

	
	CALL mp_finalize( )
	
	IF (io_node) write(*, '(a)')	'	DONE	'
	
END PROGRAM FDPML

SUBROUTINE Group_velocity(frc, f_of_q, tau, zeu, m_loc, nr1, nr2, nr3, epsil, nat, ibrav, alat, at, ntyp, ityp, amass, & 
					omega, has_zstar, na_ifc, fd, asr, q, vg, mode)
	
	USE kinds
	USE dispersion
	USE constants,	ONLY : pi
	IMPLICIT NONE
	
	CHARACTER(LEN=256) :: asr
	INTEGER, PARAMETER :: nrwsx = 200
	INTEGER :: nrws, mode
	INTEGER :: nr1, nr2, nr3, nat, ibrav, ntyp
	REAL(KIND = RP), DIMENSION(nat) :: amass
	REAL(KIND = RP) :: omega, qq
	LOGICAL :: has_zstar, na_ifc, fd
	REAL(KIND=RP) :: at(3,3), atws(3,3), bg(3,3)
	REAL(KIND=RP) :: q(3), qhat(3)
	COMPLEX(KIND=CP) :: dyn(3,3,nat,nat)
	REAL(KIND = RP) :: f_of_q(3,3,nat,nat)
	INTEGER  :: ityp(nat), itau(nat)
	REAL(KIND=RP) :: alat, qh
	REAL(KIND=RP) :: rws(0:3,nrwsx)
	INTEGER :: it  !counters
	REAL(KIND = RP) :: epsil(3,3)
	REAL(KIND = RP) :: w2(3*nat)
	COMPLEX(KIND = RP) :: z(3*nat, 3*nat)
	REAL(KIND = RP) :: frc(nr1,nr2,nr3,3,3,nat,nat), zeu(3,3,nat), tau(3,nat)
	REAL(KIND = RP), ALLOCATABLE :: m_loc(:,:)
	REAL(KIND = RP)	:: dq, vg(3), qminus(3), qplus(3), wminus, wplus
	
	dq = 0.01
	
	qplus = q
	qminus = q
	qplus(1) = q(1)+dq
	qminus(1) = q(1)-dq
	
	CALL disp(frc, f_of_q, tau, zeu, m_loc, nr1, nr2, nr3, epsil, nat, ibrav, alat, at, ntyp, ityp, amass, & 
					omega, has_zstar, na_ifc, fd, asr, qplus, w2, z)
					
	wplus = sqrt(w2(mode))
					
	CALL disp(frc, f_of_q, tau, zeu, m_loc, nr1, nr2, nr3, epsil, nat, ibrav, alat, at, ntyp, ityp, amass, & 
					omega, has_zstar, na_ifc, fd, asr, qminus, w2, z)
	
	wminus = sqrt(w2(mode))
					
	vg(1) = (wplus-wminus)/(2*dq*2*pi)
	
	
	qplus = q
	qminus = q
	qplus(2) = q(2)+dq
	qminus(2) = q(2)-dq
	
	CALL disp(frc, f_of_q, tau, zeu, m_loc, nr1, nr2, nr3, epsil, nat, ibrav, alat, at, ntyp, ityp, amass, & 
					omega, has_zstar, na_ifc, fd, asr, qplus, w2, z)
					
	wplus = sqrt(w2(mode))
					
	CALL disp(frc, f_of_q, tau, zeu, m_loc, nr1, nr2, nr3, epsil, nat, ibrav, alat, at, ntyp, ityp, amass, & 
					omega, has_zstar, na_ifc, fd, asr, qminus, w2, z)
	
	wminus = sqrt(w2(mode))
	
	vg(2) = (wplus-wminus)/(2*dq*2*pi)
	
	
	qplus = q
	qminus = q
	qplus(3) = q(3)+dq
	qminus(3) = q(3)-dq
	
	CALL disp(frc, f_of_q, tau, zeu, m_loc, nr1, nr2, nr3, epsil, nat, ibrav, alat, at, ntyp, ityp, amass, & 
					omega, has_zstar, na_ifc, fd, asr, qplus, w2, z)
					
	wplus = sqrt(w2(mode))
					
	CALL disp(frc, f_of_q, tau, zeu, m_loc, nr1, nr2, nr3, epsil, nat, ibrav, alat, at, ntyp, ityp, amass, & 
					omega, has_zstar, na_ifc, fd, asr, qminus, w2, z)
	
	wminus = sqrt(w2(mode))
	
	vg(3) = (wplus-wminus)/(2*dq*2*pi)

	
END SUBROUTINE Group_velocity

SUBROUTINE print_time(my_preprocessing_time, my_matrix_time, my_solution_time, &
						my_postprocessing_time, PD, nrows, natoms, file_no, final_iter, &
						Transmission_coefficient, counter2)
	
	USE kinds
	USE mp_module
	IMPLICIT NONE
	INCLUDE 'mpif.h' ! MPI header file
	INCLUDE 'mkl.fi' ! MKL header fileKIABS
	INTEGER 	:: file_no
	REAL 	:: my_preprocessing_time, my_matrix_time, my_solution_time, my_postprocessing_time
	REAL	:: preprocessing_time, matrix_time, solution_time, postprocessing_time
	REAL	:: PD(3)
	INTEGER(KIND = IP)	:: natoms, nrows, counter2
	INTEGER				:: final_iter
	REAL(KIND= RP)	:: Transmission_coefficient
	
	CALL MPI_REDUCE(my_preprocessing_time, preprocessing_time, 1, MPI_REAL, MPI_SUM, root_process, &
					comm, ierr)
					
	CALL MPI_REDUCE(my_matrix_time, matrix_time, 1, MPI_REAL, MPI_SUM, root_process, &
					comm, ierr)
	
	CALL MPI_REDUCE(my_solution_time, solution_time, 1, MPI_REAL, MPI_SUM, root_process, &
					comm, ierr)
	
	CALL MPI_REDUCE(my_postprocessing_time, postprocessing_time, 1, MPI_REAL, MPI_SUM, root_process, &
					comm, ierr)
		
	IF (io_node) THEN
		WRITE (file_no, '(a, I)') 'PD(1),',	PD(1)
		WRITE (file_no, '(a, I)') 'PD(2),',	PD(2)
		WRITE (file_no, '(a, I)') 'PD(3),', PD(3)
		WRITE (file_no, '(a, I)') 'natoms,', natoms
		WRITE (file_no, '(a, I)') 'nrows,', nrows
		WRITE (file_no, '(a, I)') 'total iterations,', final_iter
		WRITE (file_no, '(a, E17.10)') 'T,', Transmission_coefficient	
		WRITE (file_no, '(a, F10.3)')	'Preprocessing Time,', preprocessing_time/world_size
		WRITE (file_no, '(a, F10.3)')	'Matrix Time,', matrix_time/world_size
		WRITE (file_no, '(a, F10.3)')	'Solution Time,', solution_time/world_size
		WRITE (file_no, '(a, F10.3)')	'Postprocessing Time,', postprocessing_time/world_size
		WRITE (file_no, '(a, F10.3)')	'Total Time,', (preprocessing_time + matrix_time + solution_time + postprocessing_time)/world_size
		WRITE (file_no, '(a, I)')	'counter2', counter2
	END IF
	
END SUBROUTINE print_time

FUNCTION maximum(i, j) result(v)

!	returns the maximum of 2 numbers

	USE kinds
	IMPLICIT NONE
	INTEGER(KIND = IP) :: i, j
	INTEGER(KIND = IP) :: v
	
	IF (i .ge. j) THEN
		v = i
	ELSE
		v = j
	END IF

END FUNCTION maximum

SUBROUTINE print_memory_usage(my_nnz, my_nrows, nrows, counter2, mem_ityp_PD, mem_ityp_TD, &
								mem_amass_TD, mem_amass_PD)

	USE kinds
	use, intrinsic :: iso_fortran_env, only : stdin=>input_unit, &
											  stdout=>output_unit, &
											  stderr=>error_unit
	USE constants, ONLY : GB_byte
	USE mp_module
	IMPLICIT NONE
	INCLUDE 'mpif.h'
	INTEGER(KIND = IP) 		:: 	my_nnz, my_nrows, counter2, nrows
	INTEGER					::	mem_ityp_TD, mem_ityp_PD, mem_amass_TD, mem_amass_PD
	REAL					::	my_memory_A, memory_A, nnz
	
	my_memory_A = (IP*my_nnz + RP*my_nnz + 2*CP*my_nnz + 2*CP*my_nrows + 2*CP*my_nrows + &
					mem_ityp_PD + mem_ityp_TD + mem_amass_PD + mem_amass_TD + &
					RP*my_nrows + 2*CP*my_nrows + 2.0_RP/8.0_RP*counter2)/GB_byte
					
	CALL MPI_REDUCE(real(my_nnz), nnz, 1, MPI_REAL, MPI_SUM, root_process, comm, ierr)
		
!	==============MEMORY USAGE OF CRITICAL VARIABLES===========================
	IF (io_node) THEN
		WRITE(stdout, '(a)')	'============ MEMORY USAGE ==============='
		WRITE(stdout, '(a25, E10.3, a3)') 'A-Matrix                         ', (IP*nnz + RP*nnz + 2*CP*nnz)/(GB_Byte), ' GB'
		WRITE(stdout, '(a25, E10.3, a3)') 'Incident Wave                    ', real(2*CP*nrows)/real(GB_Byte), ' GB'
		WRITE(stdout, '(a25, E10.3, a3)') 'Scattered Wave                   ', real(2*CP*nrows)/real(GB_Byte), ' GB'
		WRITE(stdout, '(a25, E10.3, a3)') 'K-vector                         ', real(2*CP*nrows)/real(GB_Byte), ' GB'
		WRITE(stdout, '(a25, E10.3, a3)') 'Sigma Values                     ', real(2*RP*nrows)/real(GB_Byte), ' GB'
		WRITE(stdout, '(a25, E10.3, a3)') 'borderlogic                     ', real(2.0_RP/8.0_RP*counter2)/real(GB_Byte), ' GB'
		WRITE(stdout, '(a25, E10.3, a3)') 'ityp_PD                          ', real(mem_ityp_PD)/real(GB_Byte) * world_size, ' GB'
		WRITE(stdout, '(a25, E10.3, a3)') 'ityp_TD                          ', real(mem_ityp_TD)/real(GB_Byte) * world_size, ' GB'
		WRITE(stdout, '(a25, E10.3, a3)') 'amass_PD                         ', real(mem_amass_PD)/real(GB_Byte) * world_size, ' GB'
		WRITE(stdout, '(a25, E10.3, a3)') 'amass_TD                         ', real(mem_amass_TD)/real(GB_Byte) * world_size, ' GB'
		WRITE(stdout, '(a40)') '--------------------------------------------------------'
	END IF
	
	CALL MPI_REDUCE(my_memory_A, memory_A, 1, MPI_REAL, MPI_SUM, root_process, &
					comm, ierr)
	
	if (io_node) WRITE (stdout, '(a25, E10.3, a3)') 'Total memory =           ', memory_A, ' GB'	
	

END SUBROUTINE print_memory_usage



!SUBROUTINE Terminate ( )

!	use, intrinsic :: iso_fortran_env, only : stdin=>input_unit, &
!											  stdout=>output_unit, &
!											  stderr=>error_unit
!	USE mp_module, ONLY : mp_finalize
											  
!	IMPLICIT NONE
	
!	CALL mp_finalize( )

!	WRITE(stdout, *) '----------------ABORTING----------------'	
!	STOP
!END SUBROUTINE
